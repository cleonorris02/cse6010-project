"""Secondary preprocessing step for SNP hotspot encryption.

This script consumes the raw hotspot listing (generated by `preprocessing.py`) and condenses
it into fixed-length DNA strings suitable for the XChaCha20 encryption pipeline.

Steps performed:
    1. Load the processed hotspot blocks and group them by genomic window.
    2. Collapse each block into a canonical string that stitches the hotspot reference bases.
    3. Emit a TSV (`processed_data/snp_hotspots_strings.tsv`) with the following columns:
        * `record_id` – unique identifier for the hotspot region.
        * `hotspot_positions` – comma-separated positions retained for metadata.
        * `reference` – reference DNA bases for the region.
        * `hotspot_string` – contiguous DNA string fed into the encryptor.

The C encryption module in `encryption_preprocessed/` expects the TSV to follow this format.
"""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, List

INPUT_PATH = Path("processed_data/processed_hotspots_dog.txt.txt")
OUTPUT_PATH = Path("processed_data/snp_hotspots_strings.tsv")


@dataclass
class HotspotString:
    record_id: str
    positions: str
    reference: str
    sequence: str


def parse_blocks(text: str) -> Iterable[HotspotString]:
    record_index = 0
    lines = [line.strip() for line in text.splitlines() if line.strip()]
    for idx in range(0, len(lines), 4):
        if idx + 2 >= len(lines):
            break
        pos_line = lines[idx]
        ref_line = lines[idx + 1]
        if not pos_line.startswith("Hotspot Positions:"):
            continue
        if not ref_line.startswith("Reference:"):
            continue
        record_index += 1
        record_id = f"record_{record_index:04d}"
        positions = pos_line.split(":", 1)[1].strip()
        reference = ref_line.split(":", 1)[1].strip()
        sequence = reference  # Secondary preprocessing keeps the reference bases for encryption.
        yield HotspotString(record_id, positions, reference, sequence)


def render_tsv(rows: Iterable[HotspotString]) -> str:
    header = "record_id\thotspot_positions\treference\thotspot_string"
    body = [f"{row.record_id}\t{row.positions}\t{row.reference}\t{row.sequence}" for row in rows]
    return "\n".join([header, *body]) + "\n"


def main() -> None:
    text = INPUT_PATH.read_text()
    rows: List[HotspotString] = list(parse_blocks(text))
    OUTPUT_PATH.write_text(render_tsv(rows))
    print(f"Wrote {len(rows)} hotspot strings to {OUTPUT_PATH}")


if __name__ == "__main__":
    main()
